<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>æ‹†å¤šç§å•è®¡ç®—å™¨</title>
  <link rel="stylesheet" href="style.css">
</head>

<body>
  <div class="container">
    <a href="index.html" class="btn-home" aria-label="Home">ğŸ </a>

    <button class="theme-toggle" onclick="toggleTheme()" id="themeBtn">ğŸŒ™</button>

    <h1>æ‹†å¤šç§å•è®¡ç®—å™¨</h1>

    <div class="info-box">
      <div>
        <strong>ä½¿ç”¨è¯´æ˜ï¼š</strong> è¾“å…¥æ‰€æœ‰å•†å“çš„å•ä»·ã€æ•°é‡ã€ç›®æ ‡å•ç¬”é‡‘é¢ã€ç›®æ ‡å•æ•°ï¼Œè®¡ç®—å™¨ä¼šå°†å•†å“æ‹†åˆ†æˆå°½å¯èƒ½å¤šçš„è®¢å•ã€‚
      </div>
    </div>

    <div class="section-title">ç¬¬ä¸€æ­¥ï¼šå•†å“åº“å­˜</div>
    <div id="items-container"></div>
    <button class="btn-add" onclick="addItemRow()">+ æ·»åŠ ä¸€è¡Œå•†å“</button>

    <div class="section-title">ç¬¬äºŒæ­¥ï¼šè®¾ç½®ç›®æ ‡è®¢å•</div>
    <div id="targetContainer"></div>
    <button class="btn-add" onclick="addTargetRow()">+ æ·»åŠ ç›®æ ‡é‡‘é¢</button>

    <div class="input-row" style="margin-top: 20px; background: var(--card-bg); box-shadow:var(--shadow-card);">
      <div class="input-group">
        <label>ç»Ÿä¸€å…è®¸è¯¯å·® (Â¥)</label>
        <input type="number" id="errt" value="5" onchange="saveData()">
      </div>
    </div>

    <button class="btn-primary" onclick="calculate()">è®¡ç®—æœ€ä½³æ–¹æ¡ˆ</button>
    <div id="errorMsg"
      style="display:none; margin-top:20px; padding:15px; background:var(--error-bg); color:var(--error-text); border-radius:12px; text-align:center;">
    </div>

    <div id="resultsSection" class="results-area">
      <h2>è®¡ç®—ç»“æœ</h2>
      <p style="color:var(--text-light); margin-bottom:15px; font-size:0.9rem;">
        å·²é€šè¿‡å¤§é‡éšæœºæ¨¡æ‹Ÿå¯»æ‰¾æœ€ä¼˜è§£ã€‚ç‚¹å‡»ä¸‹æ–¹å¡ç‰‡æŸ¥çœ‹ä¸åŒç­–ç•¥çš„ç»“æœï¼š
      </p>

      <div id="schemeComparison" class="scheme-grid"></div>

      <div id="detailedResults"></div>

      <button class="btn-scroll-top" onclick="window.scrollTo({top:0, behavior:'smooth'})">â†‘</button>
    </div>
  </div>

  <script>
    // --- Init ---
    document.addEventListener('DOMContentLoaded', () => {
      loadTheme();
      loadData();
    });

    function toggleTheme() {
      const html = document.documentElement;
      const next = html.getAttribute('data-theme') === 'dark' ? 'light' : 'dark';
      html.setAttribute('data-theme', next);
      localStorage.setItem('theme', next);
      document.getElementById('themeBtn').textContent = next === 'dark' ? 'â˜€ï¸' : 'ğŸŒ™';
    }
    function loadTheme() {
      const saved = localStorage.getItem('theme') || 'light';
      document.documentElement.setAttribute('data-theme', saved);
      document.getElementById('themeBtn').textContent = saved === 'dark' ? 'â˜€ï¸' : 'ğŸŒ™';
    }

    // --- Data Persistence ---
    function saveData() {
      const items = [];
      document.querySelectorAll('.item-row').forEach(row => {
        items.push({
          name: row.querySelector('.name-input').value,
          price: row.querySelector('.price-input').value,
          qty: row.querySelector('.qty-input').value
        });
      });
      const targets = [];
      document.querySelectorAll('.target-row').forEach(row => {
        targets.push({
          price: row.querySelector('.t-price').value,
          count: row.querySelector('.t-count').value
        });
      });
      const data = {
        items: items,
        targets: targets,
        errt: document.getElementById('errt').value
      };
      localStorage.setItem('gamma_calc_data', JSON.stringify(data));
    }

    function loadData() {
      const saved = localStorage.getItem('gamma_calc_data');
      if (saved) {
        const data = JSON.parse(saved);
        const iContainer = document.getElementById('items-container');
        iContainer.innerHTML = '';
        if (data.items && data.items.length) {
          data.items.forEach(item => addItemRow(item.name, item.price, item.qty));
        } else {
          addItemRow(); addItemRow();
        }

        const tContainer = document.getElementById('targetContainer');
        tContainer.innerHTML = '';
        if (data.targets && data.targets.length) {
          data.targets.forEach(t => addTargetRow(t.price, t.count));
        } else {
          addTargetRow();
        }

        document.getElementById('errt').value = data.errt || 5;
      } else {
        addItemRow(); addItemRow();
        addTargetRow();
      }
    }

    function addItemRow(name = '', price = '', qty = '') {
      const container = document.getElementById('items-container');
      const div = document.createElement('div');
      div.className = 'input-row item-row';
      div.innerHTML = `
        <div class="input-group">
          <label>å•†å“å</label>
          <input type="text" class="name-input" placeholder="ä¾‹å¦‚: å§å”§" value="${name}" onchange="saveData()">
        </div>
        <div class="input-group">
          <label>å•ä»·</label>
          <input type="number" class="price-input" placeholder="0.00" value="${price}" onchange="saveData()">
        </div>
        <div class="input-group">
          <label>åº“å­˜</label>
          <input type="number" class="qty-input" placeholder="0" value="${qty}" onchange="saveData()">
        </div>
        <button class="btn-remove" onclick="this.parentElement.remove(); saveData()">âœ•</button>
      `;
      container.appendChild(div);
      saveData();
    }

    function addTargetRow(price = '', count = '1') {
      const container = document.getElementById('targetContainer');
      const div = document.createElement('div');
      div.className = 'target-row';
      div.innerHTML = `
        <div class="input-group">
          <label>é‡‘é¢</label>
          <input type="number" class="t-price" placeholder="188" value="${price}" onchange="saveData()">
        </div>
        <div class="input-group">
          <label>å•æ•°</label>
          <input type="number" class="t-count" value="${count}" min="1" onchange="saveData()">
        </div>
        <button class="btn-remove" onclick="this.parentElement.remove(); saveData()">âœ•</button>
      `;
      container.appendChild(div);
      saveData();
    }

    // --- Helper: Shuffle ---
    function shuffle(array) {
      let currentIndex = array.length, randomIndex;
      while (currentIndex != 0) {
        randomIndex = Math.floor(Math.random() * currentIndex);
        currentIndex--;
        [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];
      }
      return array;
    }

    // --- Main Calculation Logic ---
    function calculate() {
      const errorEl = document.getElementById('errorMsg');
      errorEl.style.display = 'none';

      // 1. Read DOM
      const items = [];
      document.querySelectorAll('.item-row').forEach(row => {
        const n = row.querySelector('.name-input').value.trim();
        const p = parseFloat(row.querySelector('.price-input').value);
        const q = parseInt(row.querySelector('.qty-input').value);
        if (!isNaN(p) && p > 0 && !isNaN(q) && q > 0) {
          items.push({ name: n || `Â¥${p}`, price: p, qty: q });
        }
      });

      let targets = [];
      document.querySelectorAll('.target-row').forEach(row => {
        const p = parseFloat(row.querySelector('.t-price').value);
        const c = parseInt(row.querySelector('.t-count').value);
        if (!isNaN(p) && p > 0 && !isNaN(c) && c > 0) {
          for (let i = 0; i < c; i++) targets.push(p);
        }
      });

      const errt = parseFloat(document.getElementById('errt').value) || 0;

      if (!items.length) return showError("è¯·è¾“å…¥å•†å“");
      if (!targets.length) return showError("è¯·è¾“å…¥ç›®æ ‡");

      window.currentItems = items; // Store for display

      const prices = items.map(i => i.price);
      const inventory = items.map(i => i.qty);

      // --- Simulation Config ---
      // Scheme A: Fixed Targets (Input), Randomized Items, 300ms
      const schemeA = runSimulation(
        [...targets],
        inventory, prices, 600,
        false, // Don't randomize target order
        "æ–¹æ¡ˆ A (è¾“å…¥é¡ºåº)"
      );

      // Scheme B: Fixed Targets (Sorted), Randomized Items, 300ms
      const targetsDesc = [...targets].sort((a, b) => b - a);
      const schemeB = runSimulation(
        targetsDesc,
        inventory, prices, 600,
        false, // Don't randomize target order
        "æ–¹æ¡ˆ B (å¤§é¢ä¼˜å…ˆ)"
      );

      // Scheme C: Random Targets, Random Items, 700ms
      const schemeC = runSimulation(
        [...targets],
        inventory, prices, 600,
        true, // Randomize target order
        "æ–¹æ¡ˆ C (éšæœºä¼˜åŒ–)"
      );

      displaySchemes([schemeA, schemeB, schemeC]);
    }

    function runSimulation(baseTargets, baseInventory, prices, durationMs, shuffleTargets, name) {
      const startTime = Date.now();
      let trials = 0;

      let bestResult = {
        name: name,
        successCount: -1, 
        results: [],
        leftVal: Infinity,
        leftoverItems: [...baseInventory],
        trials: 0
      };

      const errt = parseFloat(document.getElementById('errt').value) || 0;

      while (Date.now() - startTime < durationMs || trials === 0) {
        trials++;

        let currentTargets = [...baseTargets];
        if (shuffleTargets && trials > 1) {
          shuffle(currentTargets);
        }

        let currentInv = [...baseInventory];
        let successes = 0;
        let currentRunResults = [];
        let useMasking = false;

        // Determine Item Priority & Masking
        let itemIndices = Array.from({ length: prices.length }, (_, i) => i);
        if (trials === 1) {
          // First run always purely greedy (Expensive First)
          itemIndices.sort((a, b) => prices[b] - prices[a]);
          useMasking = false;
        } else {
          // Subsequent runs: Randomize item preference AND enable masking
          shuffle(itemIndices);
          useMasking = true;
        }

        // Process all targets in the specific order
        currentTargets.forEach(t => {
          // Pass masking flag
          const combo = findCombo(prices, currentInv, t, errt, itemIndices, useMasking);
          if (combo) {
            successes++;
            currentRunResults.push({ success: true, target: t, items: combo.items, total: combo.total });
            combo.items.forEach((c, idx) => currentInv[idx] -= c);
          } else {
            currentRunResults.push({ success: false, target: t });
          }
        });

        const leftVal = currentInv.reduce((s, c, i) => s + c * prices[i], 0);

        if (successes > bestResult.successCount ||
          (successes === bestResult.successCount && leftVal < bestResult.leftVal)) {

          bestResult = {
            name: name,
            successCount: successes,
            results: currentRunResults,
            leftVal: leftVal,
            leftoverItems: currentInv,
            trials: trials
          };
        }
      }

      bestResult.trials = trials;
      return bestResult;
    }

    /**
     * Updated findCombo with "Quantity Masking"
     * @param {boolean} useMasking - If true, randomly limits max quantity
     */
    function findCombo(prices, inventory, target, errt, indices, useMasking) {
      let best = null;
      let minDiff = Infinity;

      function search(idx, currentItems, currentSum) {
        if (currentSum >= target && currentSum <= target + errt) {
          const diff = currentSum - target;
          if (diff < minDiff) {
            minDiff = diff;
            best = [...currentItems];
          }
          if (minDiff === 0) return; 
        }

        if (best && minDiff === 0) return;
        if (currentSum > target + errt) return;
        if (idx >= indices.length) return;

        const pIdx = indices[idx];
        const p = prices[pIdx];

        // Greedy Max
        let maxCanTake = Math.min(inventory[pIdx], Math.floor((target + errt - currentSum) / p));

        // --- NEW: Quantity Masking Logic ---
        // 30% chance to artificially cap the quantity, simulating this item is "scarce"
        // This forces the algorithm to explore deeper combinations.
        if (useMasking && maxCanTake > 0 && Math.random() < 0.3) {
            maxCanTake = Math.floor(Math.random() * maxCanTake);
        }
        // -----------------------------------

        for (let q = maxCanTake; q >= 0; q--) {
          currentItems[pIdx] = q;
          search(idx + 1, currentItems, currentSum + (q * p));
          currentItems[pIdx] = 0; // Backtrack

          if (minDiff === 0) break;
        }
      }

      search(0, new Array(prices.length).fill(0), 0);

      return best ? { items: best, total: best.reduce((s, c, i) => s + c * prices[i], 0) } : null;
    }

    function showError(msg) {
      const el = document.getElementById('errorMsg');
      el.textContent = msg;
      el.style.display = 'block';
    }

    // --- Display Logic ---
    function displaySchemes(schemes) {
      const container = document.getElementById('schemeComparison');
      container.innerHTML = '';

      schemes.sort((a, b) => b.successCount - a.successCount || a.leftVal - b.leftVal);
      window.savedSchemes = schemes;

      schemes.forEach((s, idx) => {
        container.innerHTML += `
          <div class="scheme-card ${idx === 0 ? 'active' : ''}" onclick="showSchemeDetails(${idx}); highlightCard(this)">
            <div class="scheme-name">${s.name}</div>
            <div class="scheme-stat">æˆåŠŸ: ${s.successCount}/${s.results.length}</div>
            <div class="scheme-stat">å‰©ä½™: Â¥${parseFloat(s.leftVal.toFixed(2))}</div>
          </div>
        `;
      });

      if (schemes.length > 0) {
        showSchemeDetails(0);
      }

      document.getElementById('resultsSection').style.display = 'block';
      document.getElementById('resultsSection').scrollIntoView({ behavior: 'smooth' });
    }

    window.highlightCard = function (el) {
      document.querySelectorAll('.scheme-card').forEach(c => c.classList.remove('active'));
      el.classList.add('active');
    }

    window.showSchemeDetails = function (idx) {
      const s = window.savedSchemes[idx];
      const items = window.currentItems;
      const container = document.getElementById('detailedResults');

      // 1. Calculate Statistics
      let totalItemsUsed = 0;
      const usedCounts = new Array(items.length).fill(0);
      let totalUsedVal = 0;

      if (s.results) {
        s.results.forEach(r => {
          if (r.success) {
            r.items.forEach((qty, i) => {
              usedCounts[i] += qty;
              totalItemsUsed += qty;
              totalUsedVal += qty * items[i].price;
            });
          }
        });
      }

      let totalLeftoverCount = 0;
      s.leftoverItems.forEach(qty => totalLeftoverCount += qty);

      // 2. Stats Dashboard
      let html = `
         <h3 style="color:var(--primary-color); border-bottom:1px solid var(--input-bg); padding-bottom:15px; margin-top:0;">${s.name} è¯¦æƒ…</h3>
         
         <div class="stats-grid">
           <div class="stat-card">
             <div class="stat-val">${s.successCount} / ${s.results.length}</div>
             <div class="stat-label">è®¢å•å®Œæˆ</div>
           </div>
           <div class="stat-card">
             <div class="stat-val">${totalItemsUsed} / ${totalItemsUsed + totalLeftoverCount}</div>
             <div class="stat-label">å·²ç”¨å•†å“</div>
           </div>
           <div class="stat-card">
             <div class="stat-val">Â¥${parseFloat(s.leftVal.toFixed(2))}</div>
             <div class="stat-label">å‰©ä½™ä»·å€¼</div>
           </div>
           <div class="stat-card sub-stat">
             <div class="stat-val">${s.trials}</div>
             <div class="stat-label">è®¡ç®—æ¬¡æ•°</div>
           </div>
         </div>
       `;

      // 3. Helper for Tables/Lists
      function generateResponsiveSection(title, countsArray, totalVal) {
        const headerHtml = items.map(i =>
          `<th>${i.name}<br><small style="font-weight:400; opacity:0.8;">Â¥${i.price}</small></th>`
        ).join('');

        const rowHtml = countsArray.map(c => `<td>${c}</td>`).join('');

        const tableHtml = `
            <div class="table-responsive" style="margin-bottom: 20px;">
              <table><thead><tr>${headerHtml}</tr></thead><tbody><tr>${rowHtml}</tr></tbody></table>
            </div>
          `;

        // Mobile List
        let mobileRows = '';
        countsArray.forEach((count, idx) => {
          if (count > 0) {
            mobileRows += `
                <div class="mobile-summary-row">
                  <div>
                    <span class="mobile-summary-name">${items[idx].name}</span>
                    <span class="mobile-summary-price">Â¥${items[idx].price}</span>
                  </div>
                  <div style="font-weight:bold;">x ${count}</div>
                </div>
              `;
          }
        });
        const mobileHtml = `<div class="mobile-summary-container">${mobileRows}</div>`;

        return `
            <h3 style="margin-bottom:10px; margin-top:20px; color:var(--primary-color);">
              ${title} (æ€»å€¼: Â¥${parseFloat(totalVal.toFixed(2))})
            </h3>
            ${tableHtml}
            ${mobileHtml}
          `;
      }

      // 4. Used Items
      if (totalItemsUsed > 0) {
        html += generateResponsiveSection("å·²ç”¨å•†å“", usedCounts, totalUsedVal);
      }

      // 5. Leftover Items
      if (s.leftVal > 0) {
        html += generateResponsiveSection("å‰©ä½™å•†å“", s.leftoverItems, s.leftVal);
      } else if (s.successCount === s.results.length) {
        html += `<div class="summary-card" style="background:var(--success-bg); color:var(--success-text); margin-bottom:30px;">å®Œç¾ï¼æ‰€æœ‰å•†å“å·²åˆ†é…å®Œæ¯•ã€‚</div>`;
      }

      // 6. Orders List
      html += `<h3 style="color:var(--primary-color); border-bottom:1px solid var(--input-bg); padding-bottom:15px; margin-top:0;">è®¢å•åˆ—è¡¨</h3>`;

      // Sort results: Success first, then by Total Value Descending
      const sortedResults = [...s.results].sort((a, b) => {
        if (a.success && !b.success) return -1;
        if (!a.success && b.success) return 1;
        return (b.total || 0) - (a.total || 0);
      });

      sortedResults.forEach((r, i) => {
        if (r.success) {
          const itemsHtml = r.items.map((c, idx) => c > 0 ? `<span class="res-tag">${c} x ${items[idx].name} (Â¥${items[idx].price})</span>` : '').join('');

          html += `
             <div style="background:var(--row-bg); padding:20px; border-radius:16px; margin-bottom:15px; box-shadow:var(--shadow-card); border: 1px solid var(--input-bg);">
               <div style="font-weight:700; color:var(--primary-color); margin-bottom:10px; font-size:1.1rem;">
                 ğŸ“¦ è®¢å• ${i + 1}
                 <span style="color:var(--text-color); font-weight:400; font-size:0.9rem; float:right;">
                   ç›®æ ‡: Â¥${r.target} | å®é™…: Â¥${parseFloat(r.total.toFixed(2))}
                 </span>
               </div>
               <div style="display:flex; flex-wrap:wrap; gap:8px;">${itemsHtml}</div>
             </div>
           `;
        } else {
          html += `
             <div style="background:var(--error-bg); color:var(--error-text); padding:15px; border-radius:16px; margin-bottom:15px; box-shadow:var(--shadow-card); opacity:0.8;">
               <div style="font-weight:700;">âš ï¸ è®¢å• #${i + 1} å¤±è´¥</div>
               <div style="font-size:0.9rem;">æ— æ³•å‡‘å‡ºç›®æ ‡é‡‘é¢ Â¥${r.target}</div>
             </div>`;
        }
      });

      container.innerHTML = html;
    }
  </script>
</body>

</html>