<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <title>æ‹†å¤šç§å•è®¡ç®—å™¨</title>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 0;
      padding: 40px;
      background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
      min-height: 100vh;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
      background: white;
      border-radius: 15px;
      box-shadow: 0 10px 30px rgba(33, 150, 243, 0.2);
      padding: 40px;
      position: relative;
      border: 1px solid #e1f5fe;
    }

    h1 {
      text-align: center;
      color: #1565c0;
      margin-bottom: 30px;
      font-size: 2.2em;
      text-shadow: 0 2px 4px rgba(21, 101, 192, 0.1);
    }

    .input-section {
      margin-bottom: 25px;
    }

    .input-row {
      margin: 15px 0;
      padding: 15px;
      background: #f8fbff;
      border-radius: 8px;
      border-left: 4px solid #42a5f5;
      transition: all 0.3s ease;
    }

    .input-row:hover {
      background: #e3f2fd;
      transform: translateX(5px);
    }

    label {
      font-weight: 600;
      color: #1976d2;
      margin-right: 10px;
    }

    input {
      padding: 10px 12px;
      margin: 0 10px;
      border: 2px solid #e1f5fe;
      border-radius: 6px;
      font-size: 14px;
      transition: all 0.3s ease;
    }

    input:focus {
      outline: none;
      border-color: #42a5f5;
      box-shadow: 0 0 0 3px rgba(66, 165, 245, 0.1);
    }

    .parameters {
      background: #f8fbff;
      padding: 20px;
      border-radius: 10px;
      margin: 25px 0;
      border-left: 4px solid #ba68c8;
    }

    .parameters label {
      color: #6a1b9a;
    }

    .parameters input {
      border-color: #e1bee7;
    }

    .parameters input:focus {
      border-color: #ba68c8;
      box-shadow: 0 0 0 3px rgba(186, 104, 200, 0.1);
    }

    button {
      padding: 15px 30px;
      font-size: 18px;
      margin-top: 20px;
      background: linear-gradient(135deg, #42a5f5, #1976d2);
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(66, 165, 245, 0.4);
      font-weight: 600;
      width: 100%;
    }

    button:hover {
      background: linear-gradient(135deg, #1e88e5, #1565c0);
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(66, 165, 245, 0.6);
    }

    .error {
      color: #d32f2f;
      font-weight: bold;
      margin-top: 15px;
      padding: 15px;
      background: #ffebee;
      border-radius: 8px;
      border-left: 4px solid #f44336;
      text-align: center;
    }

    .input-group {
      display: inline-block;
      margin: 0 15px;
    }

    .section-title {
      color: #1565c0;
      font-size: 1.1em;
      font-weight: 600;
      margin-bottom: 15px;
      padding-bottom: 5px;
      border-bottom: 2px solid #e3f2fd;
    }

    .info-box {
      background: #e8f5e9;
      border-left: 4px solid #66bb6a;
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 20px;
      color: #2e7d32;
    }

    .price-list-input {
      width: 300px;
      padding: 12px;
      font-size: 16px;
    }

    .price-list-example {
      color: #666;
      font-size: 0.9em;
      margin-top: 5px;
      font-style: italic;
    }

    #inventorySection {
      display: none;
    }

    .setup-btn {
      width: auto !important;
      margin-top: 0 !important;
    }

    /* Results section styles */
    #resultsSection {
      display: none;
      margin-top: 40px;
      padding-top: 20px;
      border-top: 2px dashed #42a5f5;
    }

    .summary {
      text-align: center;
      font-size: 1.2em;
      color: #666;
      margin-bottom: 30px;
      padding: 20px;
      background: #f8f9ff;
      border-radius: 10px;
      border-left: 4px solid #667eea;
    }

    .results-count {
      font-weight: bold;
      color: #667eea;
      font-size: 1.3em;
    }

    .stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin-bottom: 30px;
    }

    .stat-card {
      background: white;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
      text-align: center;
      border-left: 4px solid #42a5f5;
    }

    .stat-card.success {
      border-left-color: #66bb6a;
    }

    .stat-card.warning {
      border-left-color: #42a5f5;
    }

    .stat-card.danger {
      border-left-color: #ef5350;
    }

    .stat-value {
      font-size: 2em;
      font-weight: bold;
      color: #1565c0;
    }

    .stat-label {
      color: #666;
      margin-top: 5px;
    }

    .combination {
      margin: 20px 0;
      padding: 20px;
      background: #f8fbff;
      border-radius: 10px;
      border-left: 4px solid #ba68c8;
    }

    .combination-header {
      font-weight: bold;
      color: #6a1b9a;
      margin-bottom: 10px;
      font-size: 1.1em;
    }

    .combination-items {
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
      margin: 10px 0;
    }

    .item {
      padding: 8px 15px;
      background: white;
      border-radius: 6px;
      border: 1px solid #e1f5fe;
    }

    .leftover {
      margin-top: 30px;
      padding: 20px;
      background: #eeeeff;
      border-radius: 10px;
      border-left: 4px solid #ba68c8;
    }

    table {
      border-collapse: collapse;
      width: 100%;
      margin: 10px 0;
    }

    th,
    td {
      border: 1px solid #e0e0e0;
      padding: 12px;
      text-align: center;
    }

    th {
      background: linear-gradient(135deg, #d0a3ff, #cc9dff);
      color: white;
    }

    td:last-child {
      background: #f3e5f5;
      font-weight: bold;
    }

    .reset-btn {
      background: linear-gradient(135deg, #ef5350, #d32f2f) !important;
      width: auto !important;
      margin-top: 10px !important;
    }

    .reset-btn:hover {
      background: linear-gradient(135deg, #e53935, #c62828) !important;
    }

    /* New styles for multiple target inputs */
    .target-row {
      display: flex;
      align-items: center;
      margin-bottom: 10px;
      padding: 10px;
      background: #f0f8ff;
      border-radius: 6px;
    }

    .target-input-group {
      flex: 1;
      display: flex;
      align-items: center;
    }

    .target-input-group label {
      min-width: 80px;
    }

    .delete-btn {
      background: linear-gradient(135deg, #ef5350, #d32f2f) !important;
      padding: 8px 15px !important;
      margin-left: 10px !important;
      width: auto !important;
    }

    .delete-btn:hover {
      background: linear-gradient(135deg, #e53935, #c62828) !important;
    }

    .add-btn {
      padding: 10px 20px !important;
      width: auto !important;
      margin-top: 10px !important;
    }

    /* Tab styles */
    .tabs-container {
      margin-top: 30px;
    }

    .tabs-header {
      display: flex;
      background: #f8fbff;
      border-radius: 10px 10px 0 0;
      overflow: hidden;
    }

    .tab {
      flex: 1;
      padding: 15px 20px;
      text-align: center;
      background: #e3f2fd;
      border: none;
      cursor: pointer;
      font-size: 16px;
      font-weight: 600;
      color: #1565c0;
      transition: all 0.3s ease;
      border-bottom: 3px solid transparent;
    }

    .tab:hover {
      background: #bbdefb;
    }

    .tab.active {
      background: white;
      border-bottom: 3px solid #42a5f5;
      color: #0d47a1;
    }

    .tab-content {
      display: none;
      padding: 30px;
      background: white;
      border-radius: 0 0 10px 10px;
      border: 2px solid #42a5f5;
      border-top: none;
    }

    .tab-content.active {
      display: block;
    }

    .scheme-section {
      min-height: 400px;
    }

    .scheme-title {
      text-align: center;
      color: #1565c0;
      margin-bottom: 20px;
      font-size: 1.5em;
      font-weight: bold;
    }

    .loading {
      text-align: center;
      padding: 40px;
      color: #666;
      font-size: 1.1em;
    }

    .scheme-comparison {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 15px;
      margin-bottom: 30px;
    }

    .comparison-card {
      padding: 15px;
      background: white;
      border-radius: 10px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
      text-align: center;
      cursor: pointer;
      transition: all 0.3s ease;
      border: 2px solid transparent;
    }

    .comparison-card:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
    }

    .comparison-card.active {
      border-color: #42a5f5;
      background: #f8fbff;
    }

    .comparison-card.best {
      border-color: #66bb6a;
      background: #e8f5e9;
    }
  </style>
</head>

<body>
  <div class="container">
    <h1>æ‹†å¤šç§å•è®¡ç®—å™¨</h1>

    <div class="contact-info" style="text-align: center; color: #666; margin-bottom: 20px; font-size: 0.9em;">
      é‡åˆ°äº†bugæˆ–è€…æƒ³ç»™ä¸€ç‚¹å»ºè®®ï¼Ÿ
      <br>è¯·åœ¨
      <a href="http://xhslink.com/o/2x2YmjdAGOo" target="_blank" style="color: #42a5f5; text-decoration: none;">
        å°çº¢ä¹¦å’‹è‚¥å››é¸­
      </a>è”ç³»æˆ‘ğŸ’œ
    </div>

    <div class="info-box">
      <strong>ä½¿ç”¨è¯´æ˜ï¼š</strong> å…ˆè¾“å…¥è°·å­çš„å•ä»·ï¼Œç„¶åè¾“å…¥æ¯ä¸ªä»·æ ¼çš„è°·å­éœ€è¦å¤šå°‘ä»½ã€æ¯å•å¤šå°‘é‡‘é¢ï¼Œç„¶åè®¡ç®—å™¨ä¼šç®—å‡ºæ€ä¹ˆæ‹†å•ã€‚
    </div>

    <!-- Step 1: Price List Input -->
    <div class="section-title">ç¬¬ä¸€æ­¥ï¼šè¯·è¾“å…¥è°·å­å•ä»·</div>
    <div class="input-row">
      <div class="input-group">
        <label>è°·å­å•ä»·ï¼ˆç”¨ç©ºæ ¼åˆ†å¼€ï¼‰ï¼š</label>
        <input type="text" id="priceList" class="price-list-input" placeholder="æ¯”å¦‚18 24 32 59 129" required>
      </div>
      <button type="button" onclick="setupInventoryInputs()" class="setup-btn">å¼€å§‹è¾“å…¥æ•°é‡</button>
    </div>

    <!-- Step 2: Inventory Inputs (dynamically generated) -->
    <div id="inventorySection">
      <div class="section-title">ç¬¬äºŒæ­¥ï¼šè¯·è¾“å…¥æ¯ä¸ªå•ä»·çš„æ•°é‡</div>
      <form id="inventoryForm"></form>

      <div class="parameters">
        <div class="section-title" style="color: #6a1b9a;">ç¬¬ä¸‰æ­¥ï¼šè¯·è¾“å…¥è®¡ç®—å‚æ•°</div>

        <div class="input-row">
          <div class="input-group">
            <label>æ¯å•å¯ä»¥è¶…å‡ºï¼š</label>
            <input type="number" id="errt" value="5" min="0" required>
          </div>
        </div>

        <div class="section-title" style="color: #6a1b9a; margin-top: 20px;">ç›®æ ‡ä»·æ ¼è®¾ç½®</div>
        <div id="targetInputsContainer">
          <!-- Target rows will be dynamically added here -->
          <div class="target-row" id="targetRow0">
            <div class="target-input-group">
              <label>æ¯å•ä»·æ ¼ï¼š</label>
              <input type="number" class="target-price" min="1" placeholder="æ¯”å¦‚188" required>
              <label>å¤šå°‘å•ï¼š</label>
              <input type="number" class="target-count" min="1" value="1" required>
            </div>
            <button type="button" class="delete-btn" onclick="removeTargetRow(0)" style="display: none;">åˆ é™¤</button>
          </div>
        </div>

        <button type="button" onclick="addTargetRow()" class="add-btn">+ æ·»åŠ ç›®æ ‡ä»·æ ¼</button>
      </div>

      <button type="button" onclick="calculateCombinations()">è®¡ç®—æ‹†å•æ–¹æ¡ˆ</button>
    </div>

    <div id="errorMsg" class="error"></div>

    <!-- Results Section -->
    <div id="resultsSection">
      <h1 style="margin-top: 0;">æ‹†å•æ–¹æ¡ˆè®¡ç®—ç»“æœ</h1>

      <div class="summary" id="resultsSummary">
        <!-- Summary will be populated by JavaScript -->
      </div>

      <div class="scheme-comparison" id="schemeComparison">
        <!-- Scheme comparison cards will be populated by JavaScript -->
      </div>

      <div class="tabs-container">
        <div class="tabs-header">
          <button class="tab active" onclick="switchTab('schemeA')">æ–¹æ¡ˆAï¼šæŒ‰è¾“å…¥é¡ºåº</button>
          <button class="tab" onclick="switchTab('schemeB')">æ–¹æ¡ˆBï¼šæŒ‰ä»·æ ¼æ’åº</button>
          <button class="tab" onclick="switchTab('schemeC')">æ–¹æ¡ˆCï¼šéšæœºä¼˜åŒ–</button>
        </div>

        <div id="schemeA" class="tab-content active">
          <!-- Scheme A content will be populated by JavaScript -->
        </div>

        <div id="schemeB" class="tab-content">
          <!-- Scheme B content will be populated by JavaScript -->
        </div>

        <div id="schemeC" class="tab-content">
          <!-- Scheme C content will be populated by JavaScript -->
        </div>
      </div>

      <button type="button" onclick="resetCalculator()" class="reset-btn">é‡æ–°è®¡ç®—</button>
    </div>

  </div>

  <script>
    let targetRowCount = 1;
    let currentResults = {};

    function setupInventoryInputs() {
      const priceListInput = document.getElementById('priceList').value;
      const errorMsg = document.getElementById('errorMsg');

      if (!priceListInput.trim()) {
        errorMsg.textContent = "è¯·è¾“å…¥ä»·æ ¼ã€‚";
        return;
      }

      // Parse prices from SPACE-separated list
      const prices = priceListInput.split(/\s+/) // Split by one or more spaces
        .map(price => parseFloat(price.trim()))
        .filter(price => !isNaN(price) && price > 0);

      if (prices.length === 0) {
        errorMsg.textContent = "è¯·è¾“å…¥å¤§äº0çš„ä»·æ ¼ã€‚";
        return;
      }

      // Check for duplicate prices
      const uniquePrices = new Set(prices);
      if (uniquePrices.size !== prices.length) {
        errorMsg.textContent = "è¯·è¾“å…¥ä¸ç›¸åŒçš„ä»·æ ¼ã€‚";
        return;
      }

      // Store prices for later use
      window.prices = prices;

      // Generate inventory input fields
      const form = document.getElementById('inventoryForm');
      form.innerHTML = ''; // Clear previous inputs

      prices.forEach((price, index) => {
        const div = document.createElement("div");
        div.classList.add("input-row");
        div.innerHTML = `
          <div class="input-group">
            <label>ä»·æ ¼ Â¥${price.toFixed(2)}: </label>
            <input type="number" id="available${index}" value="0" min="0" placeholder="æ•°é‡" required>
          </div>
        `;
        form.appendChild(div);
      });

      // Show inventory section
      document.getElementById('inventorySection').style.display = 'block';
      errorMsg.textContent = '';

      console.log("Prices set:", prices);
    }

    function addTargetRow() {
      const container = document.getElementById('targetInputsContainer');
      const newRow = document.createElement('div');
      newRow.className = 'target-row';
      newRow.id = 'targetRow' + targetRowCount;
      newRow.innerHTML = `
        <div class="target-input-group">
          <label>æ¯å•ä»·æ ¼ï¼š</label>
          <input type="number" class="target-price" min="1" placeholder="æ¯”å¦‚188" required>
          <label>å¤šå°‘å•ï¼š</label>
          <input type="number" class="target-count" min="1" value="1" required>
        </div>
        <button type="button" class="delete-btn" onclick="removeTargetRow(${targetRowCount})">åˆ é™¤</button>
      `;
      container.appendChild(newRow);
      targetRowCount++;

      // Show delete buttons on all rows if there's more than one
      if (targetRowCount > 1) {
        document.querySelectorAll('.delete-btn').forEach(btn => {
          btn.style.display = 'block';
        });
      }
    }

    function removeTargetRow(rowId) {
      const row = document.getElementById('targetRow' + rowId);
      if (row) {
        row.remove();
        targetRowCount--;

        // Hide delete button if only one row remains
        if (targetRowCount <= 1) {
          document.querySelectorAll('.delete-btn').forEach(btn => {
            btn.style.display = 'none';
          });
        }
      }
    }

    function switchTab(tabName) {
      // Hide all tab contents
      document.querySelectorAll('.tab-content').forEach(tab => {
        tab.classList.remove('active');
      });

      // Remove active class from all tabs
      document.querySelectorAll('.tab').forEach(tab => {
        tab.classList.remove('active');
      });

      // Show selected tab content
      document.getElementById(tabName).classList.add('active');

      // Activate selected tab
      event.target.classList.add('active');
    }

    function dot(a, b) {
      return a.reduce((sum, val, i) => sum + val * b[i], 0);
    }

    function getTargetsFromInputs() {
      const targets = [];
      const targetRows = document.querySelectorAll('.target-row');

      targetRows.forEach(row => {
        const priceInput = row.querySelector('.target-price');
        const countInput = row.querySelector('.target-count');

        if (priceInput && countInput) {
          const price = parseFloat(priceInput.value);
          const count = parseInt(countInput.value);

          if (!isNaN(price) && price > 0 && !isNaN(count) && count > 0) {
            for (let i = 0; i < count; i++) {
              targets.push(price);
            }
          }
        }
      });

      return targets;
    }

    function calculateCombinations() {
      if (!window.prices || window.prices.length === 0) {
        document.getElementById("errorMsg").textContent = "è¯·è¾“å…¥ä»·æ ¼ã€‚";
        return;
      }

      const available = [];
      for (let i = 0; i < window.prices.length; i++) {
        const a = parseInt(document.getElementById(`available${i}`).value);
        if (isNaN(a) || a < 0) {
          document.getElementById("errorMsg").textContent = "è¯·è¾“å…¥æœ‰æ•ˆçš„æ•°é‡ã€‚";
          return;
        }
        available.push(a);
      }

      const errt = parseFloat(document.getElementById("errt").value) || 0;
      const targets = getTargetsFromInputs();

      if (targets.length === 0) {
        document.getElementById("errorMsg").textContent = "è¯·è¾“å…¥è‡³å°‘ä¸€ä¸ªæœ‰æ•ˆçš„ç›®æ ‡ä»·æ ¼ã€‚";
        return;
      }

      console.log("Prices:", window.prices);
      console.log("Available items:", available);
      console.log("Targets:", targets);
      console.log("Error tolerance:", errt);

      // Calculate total target value
      const totalTargetValue = targets.reduce((sum, target) => sum + target, 0);
      const totalInventoryValue = dot(available, window.prices);

      // Show warning if inventory value is less than target value
      if (totalInventoryValue < totalTargetValue) {
        document.getElementById("errorMsg").textContent =
          `å•†å“æ€»ä»· Â¥${totalInventoryValue.toFixed(2)} å°äºç›®æ ‡è®¢å•æ€»ä»· Â¥${totalTargetValue.toFixed(2)}ï¼Œä½†å°†ç»§ç»­è®¡ç®—ã€‚`;
      } else {
        document.getElementById("errorMsg").textContent = '';
      }

      // Show loading state
      document.getElementById('resultsSection').style.display = 'block';
      document.getElementById('schemeA').innerHTML = '<div class="loading">è®¡ç®—ä¸­ï¼Œè¯·ç¨å€™...</div>';
      document.getElementById('schemeB').innerHTML = '<div class="loading">è®¡ç®—ä¸­ï¼Œè¯·ç¨å€™...</div>';
      document.getElementById('schemeC').innerHTML = '<div class="loading">è®¡ç®—ä¸­ï¼Œè¯·ç¨å€™...</div>';

      // Scroll to results
      document.getElementById('resultsSection').scrollIntoView({ behavior: 'smooth' });

      // Calculate schemes with a small delay to allow UI update
      setTimeout(() => {
        const schemeA = calculateScheme(window.prices, available, targets, errt, 'input-order');
        const schemeB = calculateScheme(window.prices, available, targets, errt, 'price-desc');
        const schemeC = calculateRandomOptimizedScheme(window.prices, available, targets, errt, 10);

        currentResults = { schemeA, schemeB, schemeC };

        // Display results
        displayResults(schemeA, schemeB, schemeC, window.prices, targets, errt, available, totalInventoryValue, totalTargetValue);
      }, 100);
    }

    function calculateScheme(prices, available, targets, errt, order) {
      let sortedTargets;

      if (order === 'input-order') {
        sortedTargets = [...targets]; // Keep input order
      } else {
        sortedTargets = [...targets].sort((a, b) => b - a); // Sort descending by price
      }

      const results = [];
      const remainingItems = [...available];

      // Try to create combinations for each target
      for (let i = 0; i < sortedTargets.length; i++) {
        const target = sortedTargets[i];

        // Sort prices descending for this combination attempt to use large prices first
        const sortedIndices = prices.map((_, index) => index)
          .sort((a, b) => prices[b] - prices[a]); // Descending order

        const sortedPrices = sortedIndices.map(i => prices[i]);
        const sortedRemaining = sortedIndices.map(i => remainingItems[i]);

        const combination = findBestCombination(sortedPrices, sortedRemaining, target, errt);

        if (combination) {
          // Map back to original indices
          const originalCombination = Array(prices.length).fill(0);
          sortedIndices.forEach((origIndex, sortedIndex) => {
            originalCombination[origIndex] = combination[sortedIndex];
          });

          const combinationTotal = dot(originalCombination, prices);
          results.push({
            target: target,
            items: originalCombination,
            total: combinationTotal,
            difference: combinationTotal - target
          });

          // Subtract used items from remaining inventory
          originalCombination.forEach((count, i) => {
            remainingItems[i] -= count;
          });
        } else {
          // Could not find valid combination for this target
          results.push({
            target: target,
            items: null,
            total: 0,
            difference: 0
          });
        }
      }

      // Calculate leftover items
      const leftoverValue = dot(remainingItems, prices);
      const successfulCombinations = results.filter(r => r.items !== null).length;

      return {
        order: order,
        combinations: results,
        leftoverItems: remainingItems,
        leftoverValue: leftoverValue,
        totalValue: dot(available, prices),
        targetCombinations: targets.length,
        successRate: successfulCombinations / targets.length,
        successfulCombinations: successfulCombinations
      };
    }

    function calculateRandomOptimizedScheme(prices, available, targets, errt, numTrials) {
      let bestScheme = null;
      let bestLeftoverValue = Infinity;

      for (let trial = 0; trial < numTrials; trial++) {
        // Create random order of targets
        const randomTargets = [...targets];
        for (let i = randomTargets.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [randomTargets[i], randomTargets[j]] = [randomTargets[j], randomTargets[i]];
        }

        const scheme = calculateScheme(prices, available, randomTargets, errt, 'input-order');

        // Choose scheme with minimum leftover value
        // If equal leftover, choose higher success rate
        if (scheme.leftoverValue < bestLeftoverValue ||
          (scheme.leftoverValue === bestLeftoverValue && scheme.successRate > bestScheme.successRate)) {
          bestScheme = scheme;
          bestLeftoverValue = scheme.leftoverValue;
        }
      }

      bestScheme.order = 'random-optimized';
      return bestScheme;
    }

    function findBestCombination(prar, available_items, target, errt) {
      const combination = Array(prar.length).fill(0);
      let bestCombination = null;
      let bestDifference = Infinity;

      function backtrack(currentIndex, currentItems, currentTotal) {
        // If we've used more than available, stop
        for (let i = 0; i < currentItems.length; i++) {
          if (currentItems[i] > available_items[i]) return;
        }

        // Check if this combination is valid (MUST be >= target, can be up to target + errt)
        if (currentTotal >= target && currentTotal <= target + errt) {
          const difference = currentTotal - target; // Always >= 0

          if (difference < bestDifference) {
            bestCombination = [...currentItems];
            bestDifference = difference;
          }

          // If we found a perfect match (exactly target), stop early
          if (difference === 0) return;
        }

        // If we've exceeded target + error, stop this branch
        if (currentTotal > target + errt) return;

        // If we've used all items or reached end of prices, stop
        if (currentIndex >= prar.length) return;

        // Try quantities in descending order (use more items first for large prices)
        const maxPossible = Math.min(
          available_items[currentIndex],
          Math.floor((target + errt - currentTotal) / prar[currentIndex])
        );

        for (let qty = maxPossible; qty >= 0; qty--) {
          const newTotal = currentTotal + qty * prar[currentIndex];

          currentItems[currentIndex] = qty;
          backtrack(
            currentIndex + 1,
            currentItems,
            newTotal
          );
          currentItems[currentIndex] = 0;

          // If we found a perfect match (exactly target), break early
          if (bestDifference === 0) break;
        }
      }

      backtrack(0, combination, 0);
      return bestCombination;
    }

    function displayResults(schemeA, schemeB, schemeC, prices, targets, errt, originalAvailable, totalInventoryValue, totalTargetValue) {
      // Find best scheme (minimum leftover value)
      const schemes = [schemeA, schemeB, schemeC];
      const bestScheme = schemes.reduce((best, current) =>
        current.leftoverValue < best.leftoverValue ? current : best
      );

      // Update summary
      const summaryElement = document.getElementById('resultsSummary');
      if (schemeA.successfulCombinations === 0 && schemeB.successfulCombinations === 0 && schemeC.successfulCombinations === 0) {
        summaryElement.innerHTML = 'æ²¡æœ‰æ‰¾åˆ°æœ‰æ•ˆçš„æ‹†å•æ–¹æ¡ˆã€‚';
        summaryElement.style.background = '#ffebee';
        summaryElement.style.borderLeftColor = '#e57373';
      } else {
        summaryElement.innerHTML = `
          <div>å•†å“æ€»ä»·: Â¥${totalInventoryValue.toFixed(2)} | ç›®æ ‡è®¢å•æ€»ä»·: Â¥${totalTargetValue.toFixed(2)}</div>
          <div style="margin-top: 10px;">
            ç›®æ ‡å•æ•°: <span class="results-count">${targets.length}</span> å• | 
            æ–¹æ¡ˆAæˆåŠŸ: <span class="results-count">${schemeA.successfulCombinations}</span> å• | 
            æ–¹æ¡ˆBæˆåŠŸ: <span class="results-count">${schemeB.successfulCombinations}</span> å• |
            æ–¹æ¡ˆCæˆåŠŸ: <span class="results-count">${schemeC.successfulCombinations}</span> å•
          </div>
        `;
      }

      // Create scheme comparison cards
      const comparisonContainer = document.getElementById('schemeComparison');
      comparisonContainer.innerHTML = `
        <div class="comparison-card ${bestScheme === schemeA ? 'best' : ''}" onclick="switchTab('schemeA')">
          <div style="margin-top: 10px; color: #666; font-size: 1.1em;">æ–¹æ¡ˆAï¼šæŒ‰è¾“å…¥é¡ºåº</div>
          <div class="stat-label">æˆåŠŸå•æ•°</div>
          <div class="stat-value">${schemeA.successfulCombinations}</div>
          <div class="stat-label">æˆåŠŸç‡</div>
          <div class="stat-value">${(schemeA.successRate * 100).toFixed(1)}%</div>
          <div class="stat-label">å‰©ä½™é‡‘é¢</div>
          <div class="stat-value">Â¥${schemeA.leftoverValue.toFixed(2)}</div>
        </div>
        <div class="comparison-card ${bestScheme === schemeB ? 'best' : ''}" onclick="switchTab('schemeB')">
          <div style="margin-top: 10px; color: #666; font-size: 1.1em;">æ–¹æ¡ˆBï¼šæŒ‰ä»·æ ¼æ’åº</div>
          <div class="stat-label">æˆåŠŸå•æ•°</div>
          <div class="stat-value">${schemeB.successfulCombinations}</div>
          <div class="stat-label">æˆåŠŸç‡</div>
          <div class="stat-value">${(schemeB.successRate * 100).toFixed(1)}%</div>
          <div class="stat-label">å‰©ä½™é‡‘é¢</div>
          <div class="stat-value">Â¥${schemeB.leftoverValue.toFixed(2)}</div>
        </div>
        <div class="comparison-card ${bestScheme === schemeC ? 'best' : ''}" onclick="switchTab('schemeC')">
          <div style="margin-top: 10px; color: #666; font-size: 1.1em;">æ–¹æ¡ˆCï¼šéšæœºä¼˜åŒ–</div>
          <div class="stat-label">æˆåŠŸå•æ•°</div>
          <div class="stat-value">${schemeC.successfulCombinations}</div>
          <div class="stat-label">æˆåŠŸç‡</div>
          <div class="stat-value">${(schemeC.successRate * 100).toFixed(1)}%</div>
          <div class="stat-label">å‰©ä½™é‡‘é¢</div>
          <div class="stat-value">Â¥${schemeC.leftoverValue.toFixed(2)}</div>
        </div>
      `;

      // Populate tab contents
      document.getElementById('schemeA').innerHTML = createSchemeDisplay(schemeA, prices, 'æ–¹æ¡ˆAï¼šæŒ‰è¾“å…¥é¡ºåº');
      document.getElementById('schemeB').innerHTML = createSchemeDisplay(schemeB, prices, 'æ–¹æ¡ˆBï¼šæŒ‰ä»·æ ¼ä»é«˜åˆ°ä½');
      document.getElementById('schemeC').innerHTML = createSchemeDisplay(schemeC, prices, 'æ–¹æ¡ˆCï¼šéšæœºä¼˜åŒ–');
    }

    function createSchemeDisplay(scheme, prices, title) {
      let html = `
    <div class="scheme-section">
      <div class="scheme-title">${title}</div>
      <div class="stats">
        <div class="stat-card ${scheme.successRate >= 0.8 ? 'success' : scheme.successRate >= 0.5 ? 'warning' : 'danger'}">
          <div class="stat-value">${scheme.successfulCombinations}</div>
          <div class="stat-label">æˆåŠŸå•æ•°</div>
        </div>
        <div class="stat-card">
          <div class="stat-value">${scheme.targetCombinations}</div>
          <div class="stat-label">ç›®æ ‡å•æ•°</div>
        </div>
        <div class="stat-card ${scheme.successRate >= 0.8 ? 'success' : scheme.successRate >= 0.5 ? 'warning' : 'danger'}">
          <div class="stat-value">${(scheme.successRate * 100).toFixed(1)}%</div>
          <div class="stat-label">æˆåŠŸç‡</div>
        </div>
        <div class="stat-card warning">
          <div class="stat-value">Â¥${scheme.leftoverValue.toFixed(2)}</div>
          <div class="stat-label">å‰©ä½™é‡‘é¢</div>
        </div>
      </div>
  `;

      // Create combinations display
      if (scheme.combinations.length > 0) {
        html += '<h3 style="color: #1565c0; margin-bottom: 15px;">æ‹†å•åˆ—è¡¨</h3>';

        // Sort combinations by target price (descending)
        const sortedCombinations = [...scheme.combinations]
          .filter(combo => combo.items !== null) // Only include successful combinations
          .sort((a, b) => b.target - a.target); // Sort by target price descending

        let comboIndex = 1;
        sortedCombinations.forEach((combo, index) => {
          if (combo.items) {
            html += `
          <div class="combination">
            <div class="combination-header">
              ç¬¬${comboIndex}å•ï¼šç›®æ ‡Â¥${combo.target} | å®é™…Â¥${combo.total.toFixed(2)} ï¼ˆ${combo.difference >= 0 ? 'è¶…å‡º' : 'ä¸è¶³'}Â¥${Math.abs(combo.difference).toFixed(2)}ï¼‰
            </div>
            <div class="combination-items">
              ${combo.items.map((count, i) =>
              count > 0 ? `<div class="item">${count} Ã— Â¥${prices[i]} = Â¥${(count * prices[i]).toFixed(2)}</div>` : ''
            ).join('')}
            </div>
          </div>
        `;
            comboIndex++;
          }
        });

        // Show failed combinations at the end
        const failedCombinations = scheme.combinations.filter(combo => combo.items === null);
        failedCombinations.forEach((combo, index) => {
          html += `
        <div class="combination" style="background: #ffebee; border-left-color: #e57373;">
          <div class="combination-header" style="color: #d32f2f;">
            æ— æ³•å®Œæˆï¼šç›®æ ‡Â¥${combo.target}
          </div>
        </div>
      `;
        });
      }


      // Create leftover display
      if (scheme.leftoverValue > 0) {
        html += `
          <div class="leftover">
            <h3 style="color: #6a1b9a; margin-top: 0;">å‰©ä½™é¡¹ç›®</h3>
            <p>å‰©ä½™æ€»é‡‘é¢ï¼šÂ¥${scheme.leftoverValue.toFixed(2)}</p>
            <table>
              <tr>
                ${prices.map(p => `<th>Â¥${p}</th>`).join('')}
                <th>æ€»é¢</th>
              </tr>
              <tr>
                ${scheme.leftoverItems.map(item => `<td>${item}</td>`).join('')}
                <td>Â¥${scheme.leftoverValue.toFixed(2)}</td>
              </tr>
            </table>
          </div>
        `;
      } else {
        html += '<div class="stat-card success" style="margin-top: 20px;"><div class="stat-value">100%</div><div class="stat-label">æ‰€æœ‰é¡¹ç›®å·²ä½¿ç”¨</div></div>';
      }

      html += '</div>';
      return html;
    }

    function resetCalculator() {
      // Reset form
      document.getElementById('priceList').value = '';
      document.getElementById('inventoryForm').innerHTML = '';
      document.getElementById('inventorySection').style.display = 'none';
      document.getElementById('resultsSection').style.display = 'none';
      document.getElementById('errorMsg').textContent = '';

      // Reset target inputs
      const container = document.getElementById('targetInputsContainer');
      container.innerHTML = `
        <div class="target-row" id="targetRow0">
          <div class="target-input-group">
            <label>æ¯å•ä»·æ ¼ï¼š</label>
            <input type="number" class="target-price" min="1" placeholder="æ¯”å¦‚188" required>
            <label>å¤šå°‘å•ï¼š</label>
            <input type="number" class="target-count" min="1" value="1" required>
          </div>
          <button type="button" class="delete-btn" onclick="removeTargetRow(0)" style="display: none;">åˆ é™¤</button>
        </div>
      `;
      targetRowCount = 1;

      // Scroll to top
      window.scrollTo({ top: 0, behavior: 'smooth' });
    }

    // Allow pressing Enter in the price list input to trigger setup
    document.getElementById('priceList').addEventListener('keypress', function (e) {
      if (e.key === 'Enter') {
        setupInventoryInputs();
      }
    });
  </script>
</body>

</html>