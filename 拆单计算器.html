<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>æ‹†å•è®¡ç®—å™¨</title>
  <link rel="stylesheet" href="style.css">
</head>

<body>
  <div class="container">
    <!-- Circular Home Button -->
    <a href="index.html" class="btn-home" aria-label="Home">ğŸ </a>

    <button class="theme-toggle" onclick="toggleTheme()" id="themeBtn">ğŸŒ™</button>

    <h1>æ‹†å•è®¡ç®—å™¨</h1>

    <div class="info-box">
      <div>
        <strong>ä½¿ç”¨è¯´æ˜ï¼š</strong> è¾“å…¥æ‰€æœ‰å•†å“çš„å•ä»·æ•°é‡å’Œç›®æ ‡å•ç¬”é‡‘é¢ï¼Œè®¡ç®—å™¨ä¼šå°†å•†å“æ‹†åˆ†æˆå°½å¯èƒ½å¤šçš„è®¢å•ã€‚
      </div>
    </div>

    <!-- Step 1: Items -->
    <div class="section-title">ç¬¬ä¸€æ­¥ï¼šå•†å“åº“å­˜</div>
    <div id="items-container"></div>
    <button class="btn-add" onclick="addItemRow()">+ æ·»åŠ ä¸€è¡Œå•†å“</button>

    <!-- Step 2: Parameters -->
    <div class="section-title">ç¬¬äºŒæ­¥ï¼šæ‹†å•è®¾ç½®</div>
    <div class="input-row" style="background: var(--card-bg); box-shadow: var(--shadow-card);">
      <div class="input-group">
        <label>æ¯å•ç›®æ ‡é‡‘é¢ (Â¥)</label>
        <input type="number" id="target" placeholder="ä¾‹å¦‚ 188" onchange="saveData()">
      </div>
      <div class="input-group">
        <label>å…è®¸è¶…å‡º (Â¥)</label>
        <input type="number" id="errt" value="5" onchange="saveData()">
      </div>
    </div>

    <button class="btn-primary" onclick="calculate()">å¼€å§‹æ‹†å•</button>
    <div id="errorMsg"
      style="display:none; margin-top:20px; padding:15px; background:var(--error-bg); color:var(--error-text); border-radius:12px; text-align:center;">
    </div>

    <!-- Results -->
    <div id="resultsSection" class="results-area">
      <h2>è®¡ç®—ç»“æœ</h2>

      <div id="combinationsContainer"></div>

      <div id="leftoverContainer" style="margin-top: 30px;"></div>

      <button class="btn-scroll-top" onclick="window.scrollTo({top:0, behavior:'smooth'})">â†‘</button>
    </div>
  </div>

  <script>
    // --- Init ---
    document.addEventListener('DOMContentLoaded', () => {
      loadTheme();
      loadData();
    });

    function toggleTheme() {
      const html = document.documentElement;
      const next = html.getAttribute('data-theme') === 'dark' ? 'light' : 'dark';
      html.setAttribute('data-theme', next);
      localStorage.setItem('theme', next);
      document.getElementById('themeBtn').textContent = next === 'dark' ? 'â˜€ï¸' : 'ğŸŒ™';
    }
    function loadTheme() {
      const saved = localStorage.getItem('theme') || 'light';
      document.documentElement.setAttribute('data-theme', saved);
      document.getElementById('themeBtn').textContent = saved === 'dark' ? 'â˜€ï¸' : 'ğŸŒ™';
    }

    // --- Data Persistence ---
    function saveData() {
      const items = [];
      document.querySelectorAll('.item-row').forEach(row => {
        items.push({
          name: row.querySelector('.name-input').value,
          price: row.querySelector('.price-input').value,
          qty: row.querySelector('.qty-input').value
        });
      });
      const data = {
        items: items,
        target: document.getElementById('target').value,
        errt: document.getElementById('errt').value
      };
      localStorage.setItem('split_calc_data', JSON.stringify(data));
    }

    function loadData() {
      const saved = localStorage.getItem('split_calc_data');
      const container = document.getElementById('items-container');
      container.innerHTML = '';

      if (saved) {
        const data = JSON.parse(saved);
        if (data.items && data.items.length) {
          data.items.forEach(item => addItemRow(item.name, item.price, item.qty));
        } else {
          initEmptyRows();
        }
        document.getElementById('target').value = data.target || '';
        document.getElementById('errt').value = data.errt || 5;
      } else {
        initEmptyRows();
      }
    }

    function initEmptyRows() {
      addItemRow(); addItemRow();
    }

    function addItemRow(name = '', price = '', qty = '') {
      const container = document.getElementById('items-container');
      const div = document.createElement('div');
      div.className = 'input-row item-row';
      div.innerHTML = `
        <div class="input-group" style="flex: 1.5;">
          <label>å•†å“å (é€‰å¡«)</label>
          <input type="text" class="name-input" placeholder="ä¾‹å¦‚: å§å”§" value="${name}" onchange="saveData()">
        </div>
        <div class="input-group">
          <label>å•ä»· (Â¥)</label>
          <input type="number" class="price-input" placeholder="0.00" min="0" step="0.01" value="${price}" onchange="saveData()">
        </div>
        <div class="input-group">
          <label>åº“å­˜æ•°é‡</label>
          <input type="number" class="qty-input" placeholder="0" min="0" value="${qty}" onchange="saveData()">
        </div>
        <button class="btn-remove" onclick="this.parentElement.remove(); saveData()">âœ•</button>
      `;
      container.appendChild(div);
      saveData();
    }

    // --- Algorithm: Greedy Backtracking with Quantity Masking ---

    // Fisher-Yates Shuffle
    function shuffle(array) {
      let currentIndex = array.length, randomIndex;
      while (currentIndex != 0) {
        randomIndex = Math.floor(Math.random() * currentIndex);
        currentIndex--;
        [array[currentIndex], array[randomIndex]] = [
          array[randomIndex], array[currentIndex]];
      }
      return array;
    }

    function showError(msg) {
      const el = document.getElementById('errorMsg');
      el.textContent = msg;
      el.style.display = 'block';
    }

    function calculate() {
      const errorEl = document.getElementById('errorMsg');
      errorEl.style.display = 'none';

      // 1. Parse Inputs
      const items = [];
      document.querySelectorAll('.item-row').forEach(row => {
        const n = row.querySelector('.name-input').value.trim();
        const p = parseFloat(row.querySelector('.price-input').value);
        const q = parseInt(row.querySelector('.qty-input').value);
        if (!isNaN(p) && p > 0 && !isNaN(q) && q > 0) {
          items.push({ name: n || `Â¥${p}`, price: p, qty: q });
        }
      });

      const target = parseFloat(document.getElementById('target').value);
      const errt = parseFloat(document.getElementById('errt').value) || 0;

      if (items.length === 0) return showError("è¯·è¾“å…¥æœ‰æ•ˆå•†å“");
      if (isNaN(target) || target <= 0) return showError("è¯·è¾“å…¥ç›®æ ‡é‡‘é¢");

      // 2. Prepare Data for Simulation
      const prices = items.map(i => i.price);
      const baseInventory = items.map(i => i.qty);
      const numItems = prices.length;

      // 3. Monte Carlo Simulation Settings
      const MAX_TIME_MS = 1000; // Run for max 1 seconds
      const startTime = Date.now();

      let bestResult = null;
      let maxOrders = -1;
      let minLeftoverVal = Infinity;
      let trials = 0;

      // 4. The Loop
      while (Date.now() - startTime < MAX_TIME_MS) {
        trials++;

        // A. Determine Search Order & Strategy
        let searchOrder = Array.from({ length: numItems }, (_, i) => i);
        let useMasking = false;

        // Run 1: Pure Greedy (High Price First) to guarantee baseline
        // Runs 2+: Randomized Order + Quantity Masking
        if (trials === 1) {
          searchOrder.sort((a, b) => prices[b] - prices[a]);
          useMasking = false;
        } else {
          shuffle(searchOrder);
          useMasking = true; // Enable masking for random trials
        }

        // B. Run Simulation
        let currentInventory = [...baseInventory];
        let currentOrders = [];
        let canMakeMore = true;

        while (canMakeMore) {
          // Pass 'useMasking' flag to the search algorithm
          const combo = findCombo(prices, currentInventory, target, errt, searchOrder, useMasking);

          if (combo) {
            currentOrders.push(combo);
            // Deduct items
            combo.items.forEach((count, idx) => currentInventory[idx] -= count);
          } else {
            canMakeMore = false;
          }

          if (currentInventory.every(c => c === 0)) canMakeMore = false;
        }

        // C. Evaluate this Run
        const leftoverVal = currentInventory.reduce((sum, count, i) => sum + (count * prices[i]), 0);

        if (currentOrders.length > maxOrders ||
          (currentOrders.length === maxOrders && leftoverVal < minLeftoverVal)) {

          maxOrders = currentOrders.length;
          minLeftoverVal = leftoverVal;
          bestResult = {
            orders: currentOrders,
            leftovers: currentInventory
          };
        }
      }

      console.log(`Ran ${trials} simulations.`);

      if (bestResult) {
        displayResults(bestResult.orders, bestResult.leftovers, items, trials);
      } else {
        displayResults([], baseInventory, items, trials);
      }
    }

    /**
     * Updated findCombo with "Quantity Masking"
     * @param {boolean} useMasking - If true, randomly limits max quantity to prevent greedy blocking
     */
    function findCombo(prices, inventory, target, errt, indices, useMasking) {
      let bestCombo = null;
      let bestDiff = Infinity;

      function search(idx, currentItems, currentSum) {
        if (bestDiff === 0) return; 

        if (currentSum >= target && currentSum <= target + errt) {
          if ((currentSum - target) < bestDiff) {
            bestDiff = currentSum - target;
            bestCombo = [...currentItems];
          }
          return;
        }

        if (currentSum > target + errt) return;
        if (idx >= indices.length) return;

        const pIndex = indices[idx];
        const p = prices[pIndex];

        // Standard Greedy Max
        let maxCanTake = Math.min(inventory[pIndex], Math.floor((target + errt - currentSum) / p));

        // --- NEW: Quantity Masking Logic ---
        // If we are in random mode, sometimes (30% chance) don't take the full amount.
        // This effectively "masks" the top quantities of this item for this specific branch.
        if (useMasking && maxCanTake > 0 && Math.random() < 0.3) {
            maxCanTake = Math.floor(Math.random() * maxCanTake); 
        }
        // -----------------------------------

        for (let q = maxCanTake; q >= 0; q--) {
          currentItems[pIndex] = q;
          search(idx + 1, currentItems, currentSum + (q * p));
          currentItems[pIndex] = 0; // Backtrack
          if (bestDiff === 0) break;
        }
      }

      search(0, new Array(prices.length).fill(0), 0);

      if (bestCombo) {
        const total = bestCombo.reduce((sum, c, i) => sum + c * prices[i], 0);
        return { items: bestCombo, total: total };
      }
      return null;
    }

    function displayResults(results, leftovers, items, trials) {
      const container = document.getElementById('combinationsContainer');
      const leftDiv = document.getElementById('leftoverContainer');

      // Clear containers
      container.innerHTML = '';
      leftDiv.innerHTML = '';

      const section = document.getElementById('resultsSection');
      section.style.display = 'block';

      // --- 1. Calculate Statistics & Per-Item Usage ---
      const totalOrders = results.length;
      const usedCounts = new Array(items.length).fill(0);
      let totalItemsInOrders = 0;

      results.forEach(order => {
        order.items.forEach((qty, idx) => {
          usedCounts[idx] += qty;
          totalItemsInOrders += qty;
        });
      });

      let totalUsedVal = 0;
      let totalLeftoverCount = 0;
      let totalLeftoverVal = 0;

      usedCounts.forEach((qty, idx) => totalUsedVal += qty * items[idx].price);
      leftovers.forEach((qty, idx) => {
        totalLeftoverCount += qty;
        totalLeftoverVal += qty * items[idx].price;
      });

      // --- 2. Helper to Generate Table + Mobile List ---
      function generateResponsiveSection(title, countsArray, totalVal) {
        // A. Desktop Table HTML
        const headerHtml = items.map(i =>
          `<th>${i.name}<br><small style="font-weight:400; opacity:0.8;">Â¥${i.price}</small></th>`
        ).join('');

        const rowHtml = countsArray.map(c => `<td>${c}</td>`).join('');

        const tableHtml = `
          <div class="table-responsive" style="margin-bottom: 20px;">
            <table><thead><tr>${headerHtml}</tr></thead><tbody><tr>${rowHtml}</tr></tbody></table>
          </div>
        `;

        // B. Mobile List HTML
        let mobileRows = '';
        countsArray.forEach((count, idx) => {
          if (count > 0) {
            mobileRows += `
              <div class="mobile-summary-row">
                <div>
                  <span class="mobile-summary-name">${items[idx].name}</span>
                  <span class="mobile-summary-price">Â¥${items[idx].price}</span>
                </div>
                <div style="font-weight:bold;">x ${count}</div>
              </div>
            `;
          }
        });
        const mobileHtml = `<div class="mobile-summary-container">${mobileRows}</div>`;

        return `
          <h3 style="margin-bottom:10px; margin-top:20px; color:var(--primary-color);">
            ${title} (æ€»å€¼: Â¥${parseFloat(totalVal.toFixed(2))})
          </h3>
          ${tableHtml}
          ${mobileHtml}
        `;
      }

      // --- 3. Build Main HTML ---
      let htmlContent = `
        <div class="stats-grid">
          <div class="stat-card">
            <div class="stat-val">${totalOrders}</div>
            <div class="stat-label">æˆåŠŸæ‹†å•</div>
          </div>
          <div class="stat-card">
            <div class="stat-val">${totalItemsInOrders} / ${totalItemsInOrders+totalLeftoverCount}</div>
            <div class="stat-label">å·²ç”¨å•†å“</div>
          </div>
          <div class="stat-card">
            <div class="stat-val">Â¥${parseFloat(totalLeftoverVal.toFixed(2))}</div>
            <div class="stat-label">å‰©ä½™é‡‘é¢</div>
          </div>
          <div class="stat-card sub-stat">
            <div class="stat-val">${trials || 0}</div>
            <div class="stat-label">è®¡ç®—æ¬¡æ•°</div>
          </div>
        </div>
      `;

      if (totalItemsInOrders > 0) {
        htmlContent += generateResponsiveSection("å·²ç”¨å•†å“", usedCounts, totalUsedVal);
      }

      if (totalLeftoverVal > 0) {
        htmlContent += generateResponsiveSection("å‰©ä½™å•†å“", leftovers, totalLeftoverVal);
      } else if (results.length > 0) {
        htmlContent += '<div class="summary-card" style="background:var(--success-bg); color:var(--success-text); margin-bottom:30px;">å®Œç¾ï¼æ‰€æœ‰å•†å“å·²åˆ†é…å®Œæ¯•ã€‚</div>';
      }

      // --- 4. Append Order Cards ---
      if (results.length === 0) {
        htmlContent += '<div class="summary-card" style="background:var(--error-bg); color:var(--error-text);">æ— æ³•ç»„æˆä»»ä½•ç¬¦åˆæ¡ä»¶çš„è®¢å•</div>';
      } else {
        htmlContent += `<h3 style="color:var(--primary-color); border-bottom:1px solid var(--input-bg); padding-bottom:15px; margin-top:0;">è®¢å•è¯¦æƒ…</h3>`;
        results.forEach((r, i) => {
          let itemsHtml = r.items.map((c, idx) => c > 0 ? `<span class="tag">${c} x ${items[idx].name} (Â¥${items[idx].price})</span>` : '').join('');

          htmlContent += `
            <div style="background:var(--row-bg); padding:20px; border-radius:16px; margin-bottom:15px; box-shadow:var(--shadow-card); border: 1px solid var(--input-bg);">
              <div style="font-weight:700; color:var(--primary-color); margin-bottom:10px; font-size:1.1rem;">
                ğŸ“¦ è®¢å• ${i + 1} <span style="color:var(--text-color); font-weight:400; font-size:0.9rem; float:right;">æ€»ä»·: Â¥${parseFloat(r.total.toFixed(2))}</span>
              </div>
              <div style="display:flex; flex-wrap:wrap; gap:8px;">${itemsHtml}</div>
            </div>
          `;
        });
      }

      container.innerHTML = htmlContent;

      // Inject Tag Style
      if (!document.getElementById('split-tag-style')) {
        const style = document.createElement('style');
        style.id = 'split-tag-style';
        style.innerHTML = `.tag { display:inline-block; background:var(--input-bg); padding:6px 12px; border-radius:20px; font-size:0.9rem; color:var(--text-color); }`;
        document.head.appendChild(style);
      }

      section.scrollIntoView({ behavior: 'smooth' });
    }
  </script>
</body>

</html>