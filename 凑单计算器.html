<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å‡‘å•è®¡ç®—å™¨</title>
    <link rel="stylesheet" href="style.css">
</head>

<body>
    <div class="container">
        <!-- Circular Home Button -->
        <a href="index.html" class="btn-home" aria-label="Home">ğŸ </a>

        <button class="theme-toggle" onclick="toggleTheme()" id="themeBtn">ğŸŒ™</button>

        <h1>å‡‘å•è®¡ç®—å™¨</h1>

        <div class="info-box">
            <div>
                <strong>ä½¿ç”¨è¯´æ˜ï¼š</strong> è¾“å…¥å•†å“çš„å•ä»·ã€ï¼ˆé€‰å¡«ï¼‰æœ€ä½/æœ€é«˜æ•°é‡ã€ç›®æ ‡æ€»ä»·ã€‚è®¡ç®—å™¨ä¼šæ‰¾å‡ºæ‰€æœ‰æ»¡è¶³æ•°é‡é™åˆ¶ä¸”æ€»ä»·æœ€æ¥è¿‘ç›®æ ‡çš„æ–¹æ¡ˆã€‚
            </div>
        </div>

        <!-- Step 1: Items -->
        <div class="section-title">ç¬¬ä¸€æ­¥ï¼šæ·»åŠ å•†å“</div>
        <div id="items-container"></div>
        <button class="btn-add" onclick="addItemRow()">+ æ·»åŠ ä¸€è¡Œå•†å“</button>

        <!-- Step 2: Parameters -->
        <div class="section-title">ç¬¬äºŒæ­¥ï¼šè®¾ç½®ç›®æ ‡</div>
        <div class="input-row" style="background: var(--card-bg); box-shadow: var(--shadow-card);">
            <div class="input-group">
                <label>ç›®æ ‡æ€»ä»· (Â¥)</label>
                <input type="number" id="target" placeholder="ä¾‹å¦‚ 300" onchange="saveData()">
            </div>
            <div class="input-group">
                <label>å…è®¸è¶…å‡º (Â¥)</label>
                <input type="number" id="errt" value="0" min="0" onchange="saveData()">
            </div>
        </div>

        <button class="btn-primary" onclick="calculate()">å¼€å§‹è®¡ç®—</button>

        <!-- Error Message -->
        <div id="errorMsg"
            style="display:none; margin-top:20px; padding:15px; background:var(--error-bg); color:var(--error-text); border-radius:12px; text-align:center;">
        </div>

        <!-- Results -->
        <div id="resultsSection" class="results-area">
            <h2>è®¡ç®—ç»“æœ</h2>
            <div id="resultsSummary" class="summary-card"></div>

            <!-- Table wrapper with sticky header enabled via CSS -->
            <div class="table-responsive">
                <table id="resultsTable"></table>
            </div>

            <!-- Mobile results container -->
            <div id="mobileResults" class="mobile-results-container"></div>

            <button class="btn-scroll-top" onclick="window.scrollTo({top:0, behavior:'smooth'})">â†‘</button>
        </div>
    </div>

    <script>
        // --- Init ---
        document.addEventListener('DOMContentLoaded', () => {
            loadTheme();
            loadData();
        });

        // --- Theme Logic ---
        function toggleTheme() {
            const html = document.documentElement;
            const next = html.getAttribute('data-theme') === 'dark' ? 'light' : 'dark';
            html.setAttribute('data-theme', next);
            localStorage.setItem('theme', next);
            document.getElementById('themeBtn').textContent = next === 'dark' ? 'â˜€ï¸' : 'ğŸŒ™';
        }
        function loadTheme() {
            const saved = localStorage.getItem('theme') || 'light';
            document.documentElement.setAttribute('data-theme', saved);
            document.getElementById('themeBtn').textContent = saved === 'dark' ? 'â˜€ï¸' : 'ğŸŒ™';
        }

        // --- Data Persistence ---
        function saveData() {
            const items = [];
            document.querySelectorAll('.item-row').forEach(row => {
                items.push({
                    name: row.querySelector('.name-input').value,
                    price: row.querySelector('.price-input').value,
                    qty: row.querySelector('.qty-input').value,
                    max: row.querySelector('.max-input').value // Save Max input
                });
            });
            const data = {
                items: items,
                target: document.getElementById('target').value,
                errt: document.getElementById('errt').value
            };
            localStorage.setItem('fill_calc_data', JSON.stringify(data));
        }

        function loadData() {
            const saved = localStorage.getItem('fill_calc_data');
            const container = document.getElementById('items-container');
            container.innerHTML = '';

            if (saved) {
                const data = JSON.parse(saved);
                if (data.items && data.items.length > 0) {
                    data.items.forEach(item => addItemRow(item.name, item.price, item.qty, item.max));
                } else {
                    initEmptyRows();
                }
                document.getElementById('target').value = data.target || '';
                document.getElementById('errt').value = data.errt || 0;
            } else {
                initEmptyRows();
            }
        }

        function initEmptyRows() {
            addItemRow(); addItemRow(); addItemRow();
        }

        // --- UI Logic ---
        function addItemRow(name = '', price = '', qty = '', max = '') {
            const container = document.getElementById('items-container');
            const div = document.createElement('div');
            div.className = 'input-row item-row';
            
            // Note: We use a split container for the 3rd input-group to fit Min and Max 
            // on the same visual row (or grid cell on mobile) without breaking the 
            // 2-row limit or the external CSS grid layout.
            div.innerHTML = `
        <div class="input-group" style="flex: 1.5;">
          <label>å•†å“å (é€‰å¡«)</label>
          <input type="text" class="name-input" placeholder="ä¾‹å¦‚: å§å”§" value="${name}" onchange="saveData()">
        </div>
        <div class="input-group">
          <label>å•ä»· (Â¥)</label>
          <input type="number" class="price-input" placeholder="0.00" min="0" step="0.01" value="${price}" onchange="saveData()">
        </div>
        <div class="input-group">
          <div style="display: flex; gap: 8px;">
            <div style="flex: 1;">
               <label style="display:block; font-size: 0.85rem; font-weight: 600; color: var(--text-light); margin-bottom: 4px; margin-left: 2px;">æœ€ä½</label>
               <input type="number" class="qty-input" placeholder="0" min="0" value="${qty}" onchange="saveData()" style="width: 100%;">
            </div>
            <div style="flex: 1;">
               <label style="display:block; font-size: 0.85rem; font-weight: 600; color: var(--text-light); margin-bottom: 4px; margin-left: 2px;">æœ€å¤š</label>
               <input type="number" class="max-input" placeholder="ä¸é™" min="0" value="${max}" onchange="saveData()" style="width: 100%;">
            </div>
          </div>
        </div>
        <button class="btn-remove" onclick="this.parentElement.remove(); saveData()">âœ•</button>
      `;
            container.appendChild(div);
            saveData();
        }

        function showError(msg) {
            const el = document.getElementById('errorMsg');
            el.textContent = msg;
            el.style.display = 'block';
        }

        // --- Algorithm: Recursive Combination Finder ---
        function calculate() {
            const errorEl = document.getElementById('errorMsg');
            errorEl.style.display = 'none';

            const items = [];

            // Read Inputs
            document.querySelectorAll('.item-row').forEach(row => {
                const n = row.querySelector('.name-input').value.trim();
                const p = parseFloat(row.querySelector('.price-input').value);
                const q = parseInt(row.querySelector('.qty-input').value);
                const m = parseInt(row.querySelector('.max-input').value); // Read Max
                
                if (!isNaN(p) && p > 0) {
                    items.push({
                        name: n || `Â¥${p}`,
                        price: p,
                        min: isNaN(q) ? 0 : q,
                        max: isNaN(m) ? Infinity : m // Default to Infinity if empty
                    });
                }
            });

            const target = parseFloat(document.getElementById('target').value);
            const errt = parseFloat(document.getElementById('errt').value) || 0;

            if (items.length === 0) return showError("è¯·è‡³å°‘è¾“å…¥ä¸€ä¸ªæœ‰æ•ˆçš„å•†å“å•ä»·ã€‚");
            if (isNaN(target) || target <= 0) return showError("è¯·è¾“å…¥æœ‰æ•ˆçš„ç›®æ ‡æ€»ä»·ã€‚");

            // Sort items by price descending for better pruning
            items.sort((a, b) => b.price - a.price);

            const results = [];
            const len = items.length;
            const prices = items.map(i => i.price);
            const minItems = items.map(i => i.min);
            
            // Calculate mandatory base cost from minimum quantities
            let baseCost = 0;
            let maxPossibleTotal = 0;

            for (let i = 0; i < len; i++) {
                if (items[i].max < items[i].min) {
                     return showError(`å•†å“ "${items[i].name}" çš„æœ€å¤§æ•°é‡ä¸èƒ½å°äºæœ€å°æ•°é‡ã€‚`);
                }
                baseCost += items[i].price * items[i].min;

                // Calculate max possible total to check if target is reachable
                if (maxPossibleTotal !== Infinity) {
                    if (items[i].max === Infinity) {
                        maxPossibleTotal = Infinity;
                    } else {
                        maxPossibleTotal += items[i].price * items[i].max;
                    }
                }
            }

            if (baseCost > target + errt) {
                return showError(`æœ€ä½æ•°é‡çš„æ€»ä»· (Â¥${baseCost.toFixed(2)}) å·²ç»è¶…è¿‡äº†ä¸Šé™ (Â¥${(target + errt).toFixed(2)})ã€‚`);
            }

            if (maxPossibleTotal < target) {
                return showError(`å³ä½¿é€‰äº†æ‰€æœ‰å•†å“çš„æœ€å¤§æ•°é‡ï¼Œæ€»ä»· (Â¥${maxPossibleTotal.toFixed(2)}) ä»æœªè¾¾åˆ°ç›®æ ‡ (Â¥${target})ã€‚`);
            }

            // We solve for the *additional* quantity (delta) for each item
            // such that: min <= min + delta <= max
            // Therefore: 0 <= delta <= max - min
            const maxDeltas = items.map(i => i.max === Infinity ? Infinity : i.max - i.min);

            const remainingMin = Math.max(0, target - baseCost);
            const remainingMax = target + errt - baseCost;

            // Limit Flag
            let limitReached = false;
            const MAX_RESULTS = 500;

            function search(index, currentCounts, currentSum) {
                if (limitReached) return;

                // Only check and add results when we have considered ALL items
                if (index === len) {
                    if (currentSum >= remainingMin && currentSum <= remainingMax) {
                        // Check Limit
                        if (results.length >= MAX_RESULTS) {
                            limitReached = true;
                            return;
                        }

                        // Reconstruct total counts (min + delta)
                        const totalCounts = currentCounts.map((delta, i) => delta + minItems[i]);
                        const totalVal = totalCounts.reduce((s, c, i) => s + c * prices[i], 0);
                        results.push([...totalCounts, totalVal]);
                    }
                    return;
                }

                // Pruning 1: If currentSum already exceeds max, stop this branch
                if (currentSum > remainingMax) return;

                const price = prices[index];
                
                // Calculate max possible delta based on Budget
                const budgetMaxQty = Math.floor((remainingMax - currentSum) / price);
                
                // The actual limit for this item is the smaller of:
                // 1. What the budget allows
                // 2. The user-defined upper bound (delta limit)
                const limit = Math.min(budgetMaxQty, maxDeltas[index]);

                for (let delta = 0; delta <= limit; delta++) {
                    currentCounts[index] = delta;
                    search(index + 1, currentCounts, currentSum + (delta * price));
                    currentCounts[index] = 0; // Backtrack
                    if (limitReached) return; // Break loop if limit hit
                }
            }

            search(0, new Array(len).fill(0), 0);

            // Sorting results by Total Price, then by Item Quantities
            results.sort((a, b) => {
                const totalA = a[a.length - 1];
                const totalB = b[b.length - 1];
                if (Math.abs(totalA - totalB) > 0.001) return totalA - totalB;
                // If totals are same, prefer more diverse items or standard sort
                for (let i = 0; i <= len - 1; i++) {
                    if (a[i] !== b[i]) return b[i] - a[i];
                }
                return 0;
            });

            displayResults(results, items, limitReached);
        }

        function displayResults(results, items, limitReached) {
            const section = document.getElementById('resultsSection');
            const summary = document.getElementById('resultsSummary');
            const table = document.getElementById('resultsTable');
            const mobileContainer = document.getElementById('mobileResults');

            // Handle Warning Banner
            const existingWarning = document.getElementById('limitWarningBanner');
            if (existingWarning) existingWarning.remove();

            section.style.display = 'block';
            mobileContainer.innerHTML = '';
            table.innerHTML = '';

            if (results.length === 0) {
                summary.innerHTML = "æœªæ‰¾åˆ°æ»¡è¶³æ¡ä»¶çš„æ–¹æ¡ˆ";
                summary.style.backgroundColor = "var(--error-bg)";
                summary.style.color = "var(--error-text)";
                return;
            }

            if (limitReached) {
                const warning = document.createElement('div');
                warning.id = 'limitWarningBanner';
                warning.className = 'limit-warning';
                warning.innerHTML = `<span>ç»“æœè¿‡å¤šï¼Œä»…æ˜¾ç¤ºå‰ 500 æ¡æ–¹æ¡ˆã€‚å»ºè®®å¢åŠ â€œæœ€ä½æ•°é‡â€æˆ–å‡å°‘â€œå…è®¸è¶…å‡ºâ€é‡‘é¢ã€‚</span>`;
                summary.after(warning);
            }

            summary.innerHTML = `æˆåŠŸæ‰¾åˆ° <b>${results.length}</b> ç§æ–¹æ¡ˆ`;
            summary.style.backgroundColor = "var(--success-bg)";
            summary.style.color = "var(--success-text)";

            // --- 1. Build Desktop Table ---
            let headerHTML = '<thead><tr>';
            items.forEach(item => {
                headerHTML += `<th>${item.name}<br><small style="font-weight:400; opacity:0.8;">Â¥${item.price}</small></th>`;
            });
            headerHTML += '<th>æ€»ä»·</th></tr></thead>';
            table.innerHTML = headerHTML;

            const tbody = document.createElement('tbody');
            results.forEach(row => {
                const tr = document.createElement('tr');
                for (let i = 0; i < row.length - 1; i++) {
                    const td = document.createElement('td');
                    td.textContent = row[i];
                    tr.appendChild(td);
                }
                const totalTd = document.createElement('td');
                totalTd.innerHTML = `<b>Â¥${parseFloat(row[row.length - 1].toFixed(2))}</b>`;
                tr.appendChild(totalTd);
                tbody.appendChild(tr);
            });
            table.appendChild(tbody);

            // --- 2. Build Mobile Cards ---
            results.forEach((row, index) => {
                const totalVal = row[row.length - 1];

                let itemsHtml = '';
                for (let i = 0; i < row.length - 1; i++) {
                    const count = row[i];
                    if (count > 0) {
                        itemsHtml += `
              <div class="result-item-line">
                <span class="result-item-name">${items[i].name} (Â¥${items[i].price})</span>
                <span style="font-weight:600;">x ${count}</span>
              </div>
            `;
                    }
                }

                const card = document.createElement('div');
                card.className = 'result-card';
                card.innerHTML = `
          <div class="result-card-header">
            <span>æ–¹æ¡ˆ ${index + 1}</span>
            <span>Â¥${parseFloat(totalVal.toFixed(2))}</span>
          </div>
          ${itemsHtml}
        `;
                mobileContainer.appendChild(card);
            });

            section.scrollIntoView({ behavior: 'smooth' });
        }
    </script>
</body>

</html>